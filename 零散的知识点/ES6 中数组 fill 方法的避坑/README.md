js 中快速数组有很多中方式，
- 直接声明
- 使用 ES5 的方法： new Array
- 使用 ES6 的方法： new Array(1).fill()

看起来 fill 非常的简单，但你真的会用 fill 吗？
我们来聊聊

假设现在要创建一个长度为 3 元素全为 -1 的数组，很简单，直接如下

```js
const arr1 = new Array(3).fill(-1);
console.log(arr1);
```

好像没啥问题哈，别慌，我们再来看，假设要创建一个 3*3 元素全为 -1 的二维数组呢？现在该怎么做呢？
最简单的就是双循环了，这里就不写了。
是不是还是可以使用 fill 呀，来一起看一波，不知道你会怎么写哈，小生是这样写的，客官看这样可以吗？

```js
const arr2 = new Array(3).fill(new Array(3).fill(-1));
console.log(arr2);
```

小生说呀，这是可以的，不信我们执行看看结果
```js
[ 
  [ -1, -1, -1 ], 
  [ -1, -1, -1 ], 
  [ -1, -1, -1 ] 
]
```
看起来没啥毛病哈，杠杠的！
但真的没问题吗？？好吧，明说了，这样是有大问题的，我们来看下面的代码

```js
const arr2 = new Array(3).fill(new Array(3).fill(-1));

arr2[0][0] = 1;
arr2[1][1] = 2;
arr2[2][2] = 3;

console.log(arr2);
```

这里我们做了很简单的事情
- 把第 1 行第 1 列的元素设置成了 1
- 把第 2 行第 2 列的元素设置成了 2
- 把第 3 行第 3 列的元素设置成了 3

按照正常的逻辑，这里应该是如下输出：

```js
[ 
  [ 1, -1, -1 ], 
  [ -1, 2, -1 ], 
  [ -1, -1, 3 ] 
]
```

嗯嗯，正常来说应该是这样，可实际上呢？

```js
[ 
  [ 1, 2, 3 ], 
  [ 1, 2, 3 ], 
  [ 1, 2, 3 ] 
]
```

哎，咋个成这样了，其实很简单，`fill` 方法所填充的如果是对象的话，那么每一个填充的元素都是这个对象的浅拷贝，也就是同一个内存地址的对象。

