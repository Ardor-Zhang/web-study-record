# 对浏览器的缓存机制的理解

浏览器缓存的全过程

浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源 文件，并缓存资源文件与 response header，以供下次加载时对比使 用；

下一次加载资源时。

首先判断是否存在强缓存：

- cache-control (http 1.1)
- expires（http 1.0）

如果未命中强缓存，那么走协商缓存：

- If-None-Match/etag
- If-Modified-Since/last-modified

如果命中缓存，那么返回 304，如果未命中缓存，那么根据策略返回 200 etag/last-modified 和 文件

## 强缓存

使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。 强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性

- Expires
  服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发 送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存 在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。所以在 http1.1 的时候就已经弃用了

  > Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供 了对资源的缓存的更精确的控制。

- Cache-Control
  Cache-Control 可设置的字段:
  - public：设置了该字段值的资源表示可以被任何对象（包括：发送请 求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是 使用 max-age=来精确控制
  - private：设置了该字段值的资源只能被用户浏览器缓存，不允许任 何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML， 通常都要设置这个字段值，避免代理服务器(CDN)缓存
  - no-cache：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源（也就是要协商）
  - no-store：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；
  - max-age=：设置缓存的最大有效期，单位为秒
  - s-maxage=：优先级高于 max-age=，仅适用于共享缓存(CDN)，优先 级高于 max-age 或者 Expires 头
  - max-stale[=]：设置了该字段表明客户端愿意接收已经过期的资源， 但是不能超过给定的时间限制

一般来说只需要设置其中一种方式就可以实现强缓存策略，**当两种方 式一起使用时，Cache-Control 的优先级要高于 Expires**

> no-cache 和 no-store 很容易混淆：
>
> - no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也 就是说没有强缓存，**但是会有协商缓存；**
> - no-store **是指不使用任何缓存，每次请求都直接从服务器获取资源。**

## 协商缓存

如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会 发挥作用了。

上面已经说到了，命中协商缓存的条件有三个：

- cache-control = max-age=xxx 过期了
- cache-control = no-cache
- expires 过期了

使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发 生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如 果资源发生了修改，则返回修改后的资源

那么怎么判断是否发生了改变呢？

两种方式， 分别是 http 头信息中的 Etag 和 Last-Modified 属性

- If-None-Match/etag
- If-Modified-Since/last-modified

1. If-Modified-Since/last-modified
   服务器通过在响应头中添加 Last-Modified 属性来指出资源最 后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加 一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性 来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做 了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本 地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种 方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在 1 秒钟以内，被修改多次的话，那么文件 已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中 的不准确

2. If-None-Match/etag
   因为 Last-Modified 的这种可能发生的不准确性，http 中提 供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候， 在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符， 当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时， 浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值 就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值 来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改 变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式 更加精确。

当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更 高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。

强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存 副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命 中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强 缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求 的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命 中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命 中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如 果协商缓存不命中，则浏览器返回最新的资源给浏览器。

<PaoImages
  src="./images/flow.png"
  width="100%"
  title="cache flow"
/>



> 让我们更深入地探讨`Last-Modified`头的限制，特别是关于它只能精确到秒的问题。
>
> HTTP协议中的`Last-Modified`头部是用来表示资源最后一次被修改的时间。它通常以“Web格式”时间戳的形式出现，例如：
>
> ```
> Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
> ```
>
> 这个时间戳的精度是秒级的，它不包括毫秒或更小的时间单位。这意味着如果一个资源在同一秒内被修改多次，`Last-Modified`头只能反映到这一秒内的最后一次修改。如果在这一秒内有多个修改发生，客户端和服务器之间的缓存验证机制就无法检测到这些细微的变化。
>
> 例如，假设一个资源在`07:28:00`秒被修改了两次，第一次修改发生在`07:28:00.123`，第二次修改发生在`07:28:00.789`。由于`Last-Modified`只能精确到秒，它将两次修改都记录为`07:28:00`。如果一个客户端在`07:28:00.500`之后请求这个资源，并提供一个`If-Modified-Since`头部，它将无法得知在`07:28:00`秒内发生的第二次修改。
>
> 这种限制在处理高频更新的资源时尤其成问题，例如，一个频繁更新的数据文件或API响应。在这种情况下，即使资源的内容发生了变化，使用`Last-Modified`进行缓存验证可能会导致客户端收到一个`304 Not Modified`响应，并错误地使用过时的缓存数据。
>
> 相比之下，`ETag`（实体标签）提供了一种更精细的缓存验证机制。`ETag`通常是基于资源内容的哈希值或其他唯一标识符，它能够检测到资源内容的任何变化，无论这些变化发生得多么频繁或微小。因此，即使在一秒钟内资源发生了多次变化，只要内容发生了变化，`ETag`的值也会相应地变化，从而确保缓存验证的准确性。
