[toc]

# CSRF 攻击

## 1. 前言

CSRF 攻击： CSRF 全称跨站点请求伪造（Cross-Site Request Forgery), 简单理解为：

- 攻击者盗用了你的身份，使用你的身份发送恶意的请求，因为身份是你的经过认证的，因此服务器认为这个请求是合理的，但是却实现了攻击者所期望的操作，比如以你的名义发送邮件消息等。

CSRF 攻击原理和过程如下：

其中 Web A为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，User C 为 Web A 网站的合法用户。

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站A;
2. 用户信息通过验证，网站 A 生成 Cookie 并返回给客户端，此时用户 A 身份被认证以及客户端记录下来了，用户 A 可以正常发送请求到服务器 A
3. 用户为退出网站 A 之前，在同一浏览器中打开一个 TAB 访问网站 B；
4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求访问第三方站点 Web A；
5. 请求携带用户A 的 cookie向服务器 A 发起请求。由于 A 是被验证过的，因此服务器认为请求是合法的，执行请求（恶意行为）

## 2. CSRF 漏洞检测

可以用一个简单的方法来抓取一个正常请求的数据包，去掉 referer 字段后再重新提交，如果还有效，就基本可以确定存在 CSRF 漏洞。

## 3. 防御 CSRF 攻击

大致三种策略：

1. 验证 HTTP referer 字段；
2. 在请求地址中添加 token 并验证；
3. 在 http 头中自定义属性并验证。

### 3.1 验证referer

referer 会记录请求的来源地址，因此这种方法最为简单，只要在服务器检查请求的 referer 是否是本域。但是这种方法并不是万无一失的，referer是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但并不是所有浏览的 referer 实现都一致，同时referer毕竟是记录了用户的隐私，因此有的用户关闭了referer，这都是问题。

### 3.2 请求地址中添加 token

token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。

### 3.3 在 http 头中自定义属性并验证

这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。

### CSRF 攻击简介

CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种网络攻击，它利用了用户已经认证的身份。在用户不知情的情况下，攻击者诱导或利用用户的浏览器去发起恶意请求，如更改密码、转账等，这些请求看起来像是用户自己发起的。

CSRF 攻击的成功依赖于以下几点：

1. 用户已经通过身份验证在目标站点上登录。
2. 目标站点对请求没有进行足够的检查，以确认请求是用户有意发起的。

### CSRF 攻击例子

假设用户登录了银行网站 `bank.com` 并在浏览器中保持了登录状态。攻击者知道银行网站有一个转账的URL，类似于：

```
http://bank.com/transfer?amount=1000&toAccount=attacker-account
```

攻击者构造了一个诱人点击的链接或者图片，并将其隐藏在一个看似无害的网站或电子邮件中。这个链接实际上是一个请求，指向上述银行的转账URL。如果用户点击了这个链接，他们的浏览器将会在后台发起转账请求，由于用户已经登录了银行网站，请求会带上用户的认证 cookie，银行服务器可能会认为这是一个合法的用户请求并执行转账。

### 预防 CSRF 攻击的手段

1. **使用 Anti-CSRF Token**：服务器生成一个随机的token，并在表单提交时要求客户端提交这个token。由于攻击者无法获取这个token，因此无法构造有效的请求。

2. **双重验证**：对于敏感操作，如更改密码或转账，要求用户再次输入密码或发送一次性验证码。

3. **使用 SameSite Cookie 属性**：设置 `SameSite` 属性为 `Strict` 或 `Lax` 可以限制第三方网站发起的请求携带用户的cookie。

4. **检查 Referer 和 Origin 头部**：服务器可以检查 HTTP 请求的 `Referer` 或 `Origin` 头部，以确保请求是从可信的源发起的。

5. **自定义头部**：在客户端的请求中添加自定义的HTTP头部，服务器端检查这个头部。由于浏览器的同源策略，攻击者无法在跨站请求中设置自定义头部。

6. **避免使用 GET 请求进行状态改变**：GET 请求应该是安全的，不应该引起任何状态的改变。敏感操作应该使用 POST、PUT、DELETE 等类型的请求。

7. **使用安全的框架**：许多现代Web开发框架已经内置了CSRF防护机制，确保在开发中使用这些机制。

8. **注销**：教育用户在不使用应用程序时注销，尤其是在公共计算机上。

通过实施这些防护措施，可以显著降低CSRF攻击的风险。然而，最佳的安全实践是结合使用多种策略，以确保应用程序的安全性。
